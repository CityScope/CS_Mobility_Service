<html>

<head>
    <title>Arcs</title>
    <script src="https://unpkg.com/deck.gl@^6.2.0-beta.3/deckgl.min.js"></script>
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.js"></script>
    <link rel="stylesheet" type="text/css" href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.css">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style type="text/css">
    body {
        width: 100vw;
        height: 100vh;
        margin: 0;
    }
    </style>
</head>

<body>
</body>
<script type="text/javascript">
mapboxgl.accessToken = 'pk.eyJ1IjoiZG9vcmxleXJtaXQiLCJhIjoiY2pnNnh5NHJwOHp2YzJ4bXNkdWZyNWd3ZSJ9.am1Wub7LEzVfZKHAdRZe4g';

// Layers and functionsI need from deck.gl Mapbox class
var { MapboxLayer, ArcLayer, ScatterplotLayer } = deck;

// Data for arcs
var DATA_URL = 'http://localhost:7777/abm_service/Hamburg/arcs/0';

// drive red, cycle blue, walk green, PT yellow
var colors = [[255, 0, 0], [0, 0, 255], [0, 255, 0], [255, 255, 0]];

var RADIUS_SCALE = d3.scaleSqrt().domain([0, 100]).range([100, 500]);
var WIDTH_SCALE = d3.scaleLinear().domain([0, 100]).range([1, 4]);

//Create the Mapbox map
var map = new mapboxgl.Map({
    container: document.body,
    style: 'mapbox://styles/mapbox/dark-v9',
    center: [10.011590, 53.532866],
    zoom: 12,
    pitch: 35
});

var countiesLayer;
var arcsLayer;

// Load the data and layers once Mapbox map style loads
map.on('style.load', () => {
    d3.json(DATA_URL).then(loadData);
});

//Enable arc brushing on mousemove event from Mapbox
map.on('mousemove', ({ point }) => {
    if (arcsLayer) {
        arcsLayer.setProps({ mousePosition: [point.x, point.y] });
    }
});

function renderLayers({ arcs, counties }) {
    // countiesLayer = new MapboxLayer({
    //     type: ScatterplotLayer,
    //     id: 'counties',
    //     data: counties,
    //     opacity: 1,
    //     pickable: true,
    //     // onHover: this._onHover,
    //     getRadius: d => RADIUS_SCALE(d.total),
    //     getColor: d => (d.net > 0 ? TARGET_COLOR : SOURCE_COLOR)
    // });

    arcsLayer = new MapboxLayer({
        type: ArcBrushingLayer,
        id: 'arcs',
        data: arcs,
        brushRadius: 100,
        getStrokeWidth: d => WIDTH_SCALE(d.value),
        opacity: 0.5,
        getSourcePosition: d => d.source,
        getTargetPosition: d => d.target,
        getSourceColor: d => colors[d.mode],
        getTargetColor: d => colors[d.mode]
    });

    // map.addLayer(countiesLayer, 'waterway-label');
    map.addLayer(arcsLayer, 'waterway-label');
}

//Load and process data for visualization
function loadData(data) {
    var arcs = [];
    var counties = [];
    // var pairs = {};
    console.log(data)
    data.forEach((zone, i) => {
        // console.log(zone);
        var target_centroid=zone.centroid;
        var flows=zone.flows;
        Object.keys(flows).forEach(fromId => {
            var source_centroid = data[fromId].centroid;
            Object.keys(flows[fromId]).forEach(mode => {
                if (flows[fromId][mode]>0){
                    arcs.push({
                    target: target_centroid,
                    source: source_centroid,
                    value: flows[fromId][mode],
                    mode:mode
                    });
                }
            });
        });

        // add point at arc target

        // counties.push({
        //     gain: value.gain,
        //     loss: value.loss,
        //     position: targetCentroid,
        //     net: value.gain + value.loss,
        //     total: value.gain - value.loss,
        //     name: county.properties.name
        // });
    });

    // sort counties by radius large -> small
    // counties.sort((a, b) => Math.abs(b.net) - Math.abs(a.net));

    renderLayers({ arcs});
    // renderLayers({ arcs, counties });
}

// Create the brushing effect on the layer in deck.gl
// See https://github.com/uber/deck.gl/blob/master/docs/get-started/interactivity.md
class ArcBrushingLayer extends ArcLayer {
    getShaders() {
        // use customized shaders
        return Object.assign({}, super.getShaders(), {
            inject: {
                'vs:#decl': `
  uniform vec2 mousePosition;
  uniform float brushRadius;
              `,
                'vs:#main-end': `
  float brushRadiusPixels = project_scale(brushRadius);

  vec2 sourcePosition = project_position(instancePositions.xy);
  bool isSourceInBrush = distance(sourcePosition, mousePosition) <= brushRadiusPixels;

  vec2 targetPosition = project_position(instancePositions.zw);
  bool isTargetInBrush = distance(targetPosition, mousePosition) <= brushRadiusPixels;

  if (!isSourceInBrush && !isTargetInBrush) {
    vColor.a = 0.0;
  }
              `,
                'fs:#main-start': `
  if (vColor.a == 0.0) discard;
              `
            }
        });
    }

    draw(opts) {
        var { brushRadius = 1e6, mousePosition } = this.props;
        // add uniforms
        var uniforms = Object.assign({}, opts.uniforms, {
            brushRadius: brushRadius,
            mousePosition: mousePosition ?
                this.projectPosition(this.unproject(mousePosition)).slice(0, 2) : [0, 0]
        });
        super.draw(Object.assign({}, opts, { uniforms }));
    }
}
</script>

</html>