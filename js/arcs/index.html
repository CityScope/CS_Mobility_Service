<html>

<head>
    <title>Arcs</title>
    <script src="https://unpkg.com/deck.gl@^6.2.0-beta.3/deckgl.min.js"></script>
    <script src="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.js"></script>
    <link rel="stylesheet" type="text/css" href="https://api.tiles.mapbox.com/mapbox-gl-js/v0.50.0/mapbox-gl.css">
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <style type="text/css">
    body {
        width: 100vw;
        height: 100vh;
        margin: 0;
    }
    </style>
</head>

<body>
</body>
<script type="text/javascript">
mapboxgl.accessToken = 'pk.eyJ1IjoiZG9vcmxleXJtaXQiLCJhIjoiY2pnNnh5NHJwOHp2YzJ4bXNkdWZyNWd3ZSJ9.am1Wub7LEzVfZKHAdRZe4g';

// Layers and functionsI need from deck.gl Mapbox class
var { MapboxLayer, ArcLayer, ScatterplotLayer } = deck;

// Data for arcs
var ARC_DATA_URL = 'http://localhost:7777/abm_service/Hamburg/arcs/0';
var ROUTE_DATA_URL ='http://localhost:7777/abm_service/Hamburg/routes/0'

// drive red, cycle blue, walk green, PT yellow
var colors = [[255, 0, 0], [0, 0, 255], [0, 255, 0], [255, 255, 0]];

var RADIUS_SCALE = d3.scaleSqrt().domain([0, 100]).range([100, 500]);
var WIDTH_SCALE = d3.scaleLinear().domain([0, 100]).range([1, 4]);

var seconds=5;

//Create the Mapbox map
var map = new mapboxgl.Map({
    container: document.body,
    style: 'mapbox://styles/mapbox/dark-v9',
    center: [10.011590, 53.532866],
    zoom: 12,
    pitch: 35
});

var countiesLayer;
var arcsLayer;

// Load the data and layers once Mapbox map style loads
map.on('style.load', () => {
    d3.json(ARC_DATA_URL).then(loadArcData);
    d3.json(ROUTE_DATA_URL).then(loadRouteData);
});

//Enable arc brushing on mousemove event from Mapbox
map.on('mousemove', ({ point }) => {
    if (arcsLayer) {
        arcsLayer.setProps({ mousePosition: [point.x, point.y] });
    }
});

function renderLayers({ arcs}) {

    arcsLayer = new MapboxLayer({
        type: ArcBrushingLayer,
        id: 'arcs',
        data: arcs,
        brushRadius: 500,
        getStrokeWidth: d => WIDTH_SCALE(d.value),
        opacity: 0.5,
        getSourcePosition: d => d.source,
        getTargetPosition: d => d.target,
        getSourceColor: d => colors[d.mode],
        getTargetColor: d => colors[d.mode]
    });

    // map.addLayer(countiesLayer, 'waterway-label');
    map.addLayer(arcsLayer, 'waterway-label');
}

//Load and process data for visualization
function loadArcData(data) {
    // var pairs = {};
    var arcs=[];
    data.forEach((zone, i) => {
        // console.log(zone);
        var target_centroid=[zone.centroid[0]+(Math.random()-0.5)*0.0001, zone.centroid[1]+(Math.random()-0.5)*0.0001];
        var flows=zone.flows;
        Object.keys(flows).forEach(fromId => {
            var source_centroid = [data[fromId].centroid[0]+(Math.random()-0.5)*0.0001, data[fromId].centroid[1]+(Math.random()-0.5)*0.0001];
            Object.keys(flows[fromId]).forEach(mode => {
                if (flows[fromId][mode]>0){
                    arcs.push({
                    target: target_centroid,
                    source: source_centroid,
                    value: flows[fromId][mode],
                    mode:mode
                    });
                }
            });
        });
    });
    renderLayers({arcs});
}

function loadRouteData(data) {
    var points_geo = data;
    map.addSource('points', { type: 'geojson', data: points_geo });
    map.addLayer({
        "id": "points",
        "type": "circle",
        "source": "points",
        "paint": {
            "circle-radius": 3,
            // "circle-color":'red',
            "circle-color": ["case", 
                        ['==',['number',['get', 'mode']],0],['rgb', 255,0,0],
                        ['==',['number',['get', 'mode']],1],['rgb', 0,0,255],
                        ['==',['number',['get', 'mode']],2],['rgb', 0,255,0],
                        ['==',['number',['get', 'mode']],3],['rgb', 255,255,0],
                        ['rgb', 255,255,255]],
            "circle-opacity": 0.8,
        }
    });
    var timer = window.setInterval(function() {
                for (var i = 0, l = points_geo.features.length; i < l; i++) {
                    f_props=points_geo.features[i]['properties'] // creates a reference to the object
                    if (f_props.finished != true){
                        dist_to_move_m=f_props.speed*seconds/3.6;
                        finished_move=false
                        while (finished_move==false & f_props.finished==false){
                            d_to_next_node=f_props.prop_of_link_left*f_props.route['distances'][f_props.next_node_index-1]
                            move_ratio=dist_to_move_m/d_to_next_node
                            if (move_ratio<1){
                                        // just move the agent along this segment. move finished.
                                        f_props.position[0]=f_props.position[0]+move_ratio*(f_props.next_node_ll[0]-f_props.position[0])
                                        f_props.position[1]=f_props.position[1]+move_ratio*(f_props.next_node_ll[1]-f_props.position[1])
                                        f_props.prop_of_link_left=f_props.prop_of_link_left*(1-move_ratio)
                                        finished_move=true}
                                        else {
                                        //agent moves to start of next segment and then continues the move
                                        f_props.position[0]=f_props.next_node_ll[0]
                                        f_props.position[1]=f_props.next_node_ll[1]
                                        f_props.next_node_index+=1
                                        if (f_props.next_node_index==f_props.route['coordinates'].length){
                                            f_props.finished=true
                                        }
                                        else {
                                            f_props.next_node_ll=f_props.route['coordinates'][f_props.next_node_index]
                                            f_props.prop_of_link_left=1
                                            dist_to_move_m-=d_to_next_node
                                        }
                                    }
                                }
                                points_geo.features[i]['geometry']['coordinates'][0]=f_props.position[0]
                                points_geo.features[i]['geometry']['coordinates'][1]=f_props.position[1]
                            }
                }
                map.getSource("points").setData(points_geo); 
                
            }, 50);

}

// Create the brushing effect on the layer in deck.gl
// See https://github.com/uber/deck.gl/blob/master/docs/get-started/interactivity.md
class ArcBrushingLayer extends ArcLayer {
    getShaders() {
        // use customized shaders
        return Object.assign({}, super.getShaders(), {
            inject: {
                'vs:#decl': `
  uniform vec2 mousePosition;
  uniform float brushRadius;
              `,
                'vs:#main-end': `
  float brushRadiusPixels = project_scale(brushRadius);

  vec2 sourcePosition = project_position(instancePositions.xy);
  bool isSourceInBrush = distance(sourcePosition, mousePosition) <= brushRadiusPixels;

  vec2 targetPosition = project_position(instancePositions.zw);
  bool isTargetInBrush = distance(targetPosition, mousePosition) <= brushRadiusPixels;

  if (!isSourceInBrush && !isTargetInBrush) {
    vColor.a = 0.0;
  }
              `,
                'fs:#main-start': `
  if (vColor.a == 0.0) discard;
              `
            }
        });
    }

    draw(opts) {
        var { brushRadius = 1e6, mousePosition } = this.props;
        // add uniforms
        var uniforms = Object.assign({}, opts.uniforms, {
            brushRadius: brushRadius,
            mousePosition: mousePosition ?
                this.projectPosition(this.unproject(mousePosition)).slice(0, 2) : [0, 0]
        });
        super.draw(Object.assign({}, opts, { uniforms }));
    }
}
</script>

</html>